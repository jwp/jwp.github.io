<html root="2"><head><title>jwp.log.mechanics.shell-patterns</title><meta charset="utf-8"/><link as="style" rel="preload" href="../../.legacy-web/core.css"></link><link as="style" rel="preload" href="../../.legacy-web/factor.css"></link><link rel="stylesheet" href="../../.legacy-web/core.css"></link><link rel="stylesheet" href="../../.legacy-web/factor.css"></link></head><body><main><h1><span class="prefix"></span><div class="page-subject"><img class="icon" src="../../.factor-type-icon/if.fault.io/meta-chapter.svg"></img><span class="subject-identifier">shell-patterns</span><span class="element-status"><span class="nothing-missed">0</span></span><a href="http://if.fault.io/factors/meta.chapter"><code class="type">meta.chapter</code></a></div><div class="page-context"><a href="../"><img class="icon" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTYiIGhlaWdodD0iMjU2Ij48dGV4dCB4PSI0IiB5PSIwLjg4ZW0iIGZvbnQtc2l6ZT0iMjQ4Ij7wn5OcPC90ZXh0Pjwvc3ZnPg=="></img></a><span class="context-identifier">jwp.log</span></div></h1><section class="chapter"><p><span class="text.normal">The practices described here are not necessarily considered superior.</span><span class="text.line-break"> </span><span class="text.normal">Rather, it's just a protocol, pattern, to achieve some functional</span><span class="text.line-break"> </span><span class="text.normal">or aesthetic goal. The practices of a working environment will likely take</span><span class="text.line-break"> </span><span class="text.normal">precedence in most cases where some conflict of style is present.</span></p></section><section class="unspecified" documented="true" local-identifier="Bourne Limitations" id="Bourne-Limitations"><h1><span class="prefix"></span><a class="title" href="#Bourne-Limitations"><span class="text.normal">Bourne Limitations</span></a><span class="element-status"></span><div class="factor-element-meta"><span class="abstract-type"></span></div></h1><p><span class="text.normal">Limiting the used features to that of POSIX shell.</span><span class="text.line-break"> </span><span class="text.normal">While vectors can certainly be useful, often it is the case that</span><span class="text.line-break"> </span><span class="text.normal">use of non-standard features are a good indicator that</span><span class="text.line-break"> </span><span class="text.normal">shell might not be the right choice. Python, Perl, and Ruby are all</span><span class="text.line-break"> </span><span class="text.normal">likely candidates for a shell script that has evolved into something more.</span></p></section><section class="unspecified" documented="true" local-identifier="Unconditional Indentation" id="Unconditional-Indentation"><h1><span class="prefix"></span><a class="title" href="#Unconditional-Indentation"><span class="text.normal">Unconditional Indentation</span></a><span class="element-status"></span><div class="factor-element-meta"><span class="abstract-type"></span></div></h1><p><span class="text.normal">While shell is normally capable of being arbitrary indented,</span><span class="text.line-break"> </span><span class="text.normal">use of the </span><code class="command">:</code><span class="text.normal"> with an if-statement creates a natural</span><span class="text.line-break"> </span><span class="text.normal">opportunity to indent when it is desired to group a set of commands.</span></p><pre class="text.syntax"><code class="shell">if : Comment; then
	# Section
	SETTING=...
	Command ...
	export SETTING
fi
</code></pre><p><span class="text.normal">While not a substantial improvement to just indenting after a comment,</span><span class="text.line-break"> </span><span class="text.normal">there is the possibility of overriding the </span><code class="command">:</code><span class="text.normal"> to perform</span><span class="text.line-break"> </span><span class="text.normal">filtering of specific sections.</span></p></section><section class="unspecified" documented="true" local-identifier="Command Syntax with Flow Control Conditions" id="Command-Syntax-with-Flow-Control-Conditions"><h1><span class="prefix"></span><a class="title" href="#Command-Syntax-with-Flow-Control-Conditions"><span class="text.normal">Command Syntax with Flow Control Conditions</span></a><span class="element-status"></span><div class="factor-element-meta"><span class="abstract-type"></span></div></h1><p><span class="text.normal">Bracket syntax, </span><code class="">[ ... ]</code><span class="text.normal">, for conditionals is the common form among authors.</span></p><pre class="text.syntax"><code class="shell">if [ 0 = $VAR ]
then
	...
fi
</code></pre><p><span class="text.normal">However, it lends to the idea that the statement is somehow special where</span><span class="text.line-break"> </span><span class="text.normal">the flow control method is merely reacting to the exit status of a</span><span class="text.line-break"> </span><span class="text.normal">command, builtin or system.</span></p><p><span class="text.normal">By preferring "Command Syntax" for conditionals, it serves as a reminder that</span><span class="text.line-break"> </span><span class="text.normal">it is just that, a command.</span></p><pre class="text.syntax"><code class="shell">if test 0 = $VAR
then
	...
fi
</code></pre></section><section class="unspecified" documented="true" local-identifier="Subshell More" id="Subshell-More"><h1><span class="prefix"></span><a class="title" href="#Subshell-More"><span class="text.normal">Subshell More</span></a><span class="element-status"></span><div class="factor-element-meta"><span class="abstract-type"></span></div></h1><p><span class="text.normal">Subshells are a great way to limit the scope of a specific execution context.</span><span class="text.line-break"> </span><span class="text.normal">Where appropriate, use them to:</span></p><ul class="text.set"><li><p><span class="text.normal">Push and pop the current working directory: </span><code class="">(cd; pwd-sensitive-command)</code><span class="text.normal">.</span></p></li><li><p><span class="text.normal">Temporarily override environment variables. Notably, </span><code class="">PATH</code><span class="text.normal"> to control commands.</span></p></li><li><p><span class="text.normal">Leverage </span><code class="">exit</code><span class="text.normal"> based "long" jumps. Exit the subshell from a function called at any depth.</span></p></li></ul></section><section class="unspecified" documented="true" local-identifier="Grave Accent Avoidance" id="Grave-Accent-Avoidance"><h1><span class="prefix"></span><a class="title" href="#Grave-Accent-Avoidance"><span class="text.normal">Grave Accent Avoidance</span></a><span class="element-status"></span><div class="factor-element-meta"><span class="abstract-type"></span></div></h1><p><span class="text.normal">The grave accent command substitution syntax can be difficult to read in some cases.</span><span class="text.line-break"> </span><span class="text.normal">Parenthesis are much more legible and can be nested.</span></p></section><section class="unspecified" documented="true" local-identifier="Always Be Quoting" id="Always-Be-Quoting"><h1><span class="prefix"></span><a class="title" href="#Always-Be-Quoting"><span class="text.normal">Always Be Quoting</span></a><span class="element-status"></span><div class="factor-element-meta"><span class="abstract-type"></span></div></h1><p><span class="text.normal">Not always, but usually. There's no guarantee that filesystem paths are clean of</span><span class="text.line-break"> </span><span class="text.normal">field separators, but it is guaranteed that quoting your expansion will keep </span><code class="">$IFS</code><span class="text.line-break"> </span><span class="text.normal">from separating fields.</span></p></section><section class="unspecified" documented="true" local-identifier="Test Strings with Constant Prefixes" id="Test-Strings-with-Constant-Prefixes"><h1><span class="prefix"></span><a class="title" href="#Test-Strings-with-Constant-Prefixes"><span class="text.normal">Test Strings with Constant Prefixes</span></a><span class="element-status"></span><div class="factor-element-meta"><span class="abstract-type"></span></div></h1><p><span class="text.normal">While unlikely of importance today, there were shells that would drop fields given</span><span class="text.line-break"> </span><span class="text.normal">that an expansion yielded an empty string or referenced an unset variable.</span><span class="text.line-break"> </span><span class="text.normal">A common cure for this was to include a constant prefix on strings where acceptable:</span></p><pre class="text.syntax"><code class="shell"># Without the `x` prefix, "$VAR" would get dropped as a field entirely
# by some shell implementations. Even when quoted.
test x"" = x"$VAR" &#38;&#38; handle_empty_string_case
</code></pre><p><span class="text.normal">This is only useful when trying to maximize the portability of a script.</span></p></section><section class="unspecified" documented="true" local-identifier="Modern Tooling" id="Modern-Tooling"><h1><span class="prefix"></span><a class="title" href="#Modern-Tooling"><span class="text.normal">Modern Tooling</span></a><span class="element-status"></span><div class="factor-element-meta"><span class="abstract-type"></span></div></h1><dl class="text.mapping"><div id="Modern-Tooling.Linters" documented="true"><dt><a class="dkn" href="#Modern-Tooling.Linters"></a><span class="directory-key"><span class="text.normal">Linters</span></span></dt><dd><div class="status"></div><ul class="text.set"><li><p><a class="absolute" href="https://shellcheck.net">https://shellcheck.net</a></p></li></ul></dd></div></dl></section><h1 class="footing"></h1></main></body></html>